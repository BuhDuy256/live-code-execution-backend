# Checklist – Live Code Execution Backend (SWE Intern – Backend)

> Self-review checklist for the take-home assignment  
> Mark `[x]` when completed

---

## 1. Objective & Scope

- [x] Clearly understand the goal: design a **secure, asynchronous backend** for code execution
- [x] Identify the target users as **learners in a Job Simulation platform**
- [x] Distinguish in-scope vs out-of-scope (no frontend, no real K8s orchestration)
- [x] Treat this as a **case study with illustrative code**, not a production system

---

## 2. System Architecture

- [ ] Provide a high-level architecture diagram
- [ ] Clearly describe responsibilities of:
  - API Service
  - Queue system
  - Execution worker
  - Database / Storage
- [ ] Explain why a **queue-based asynchronous** architecture is used
- [ ] Show how API requests are kept **non-blocking**

---

## 3. Live Code Session

### 3.1 Create Live Code Session

- [x] Implement `POST /code-sessions`
- [x] Generate a `session_id` (UUID)
- [x] Set default session status to `ACTIVE`
- [x] Initialize programming language
- [x] Provide template code (if applicable)
- [x] Define a data model for code sessions

---

### 3.2 Autosave Code

- [x] Implement `PATCH /code-sessions/{session_id}`
- [x] Support high-frequency autosave
- [x] Persist `language` and `source_code`
- [x] Autosave **does not trigger execution**
- [x] Session remains in `ACTIVE` state

---

## 4. Code Execution (Run Code)

### 4.1 Submit Execution

- [x] Implement `POST /code-sessions/{session_id}/run`
- [x] API responds **immediately**
- [x] Return an `execution_id`
- [x] Initial execution state is `QUEUED`
- [x] No code execution in the API layer

---

### 4.2 Queue & Worker

- [x] Use a job queue (Redis / BullMQ / Celery / equivalent)
- [x] Worker runs independently from API service
- [x] Executions are processed asynchronously
- [x] Implement retry for transient failures
- [x] Prevent system overload under high concurrency

---

## 5. Execution Lifecycle & State Management

- [x] Define all execution states:
  - `QUEUED`
  - `RUNNING`
  - `COMPLETED`
  - `FAILED`
  - `TIMEOUT`
- [x] Worker updates execution state step-by-step
- [x] Track timestamps for key lifecycle events
- [x] Handle:
  - Runtime errors
  - Execution timeouts
  - Worker crashes

---

## 6. Get Execution Result API

- [x] Implement `GET /executions/{execution_id}`
- [x] Return the current execution status
- [x] When `COMPLETED`, return:
  - `stdout`
  - `stderr`
  - `execution_time_ms`
- [x] When `FAILED` or `TIMEOUT`, return meaningful error information
- [x] Do not expose sensitive system details

---

## 7. Safety & Resource Limits

- [x] Enforce execution time limits (timeout)
- [x] Enforce memory limits (conceptual explanation is sufficient)
- [x] Restrict supported programming languages
- [x] Protect against infinite loops
- [x] Mitigate repeated or abusive execution requests

---

## 8. Observability & Logging

- [x] Log the full execution lifecycle
- [x] Track `QUEUED → RUNNING → COMPLETED / FAILED`
- [x] Provide logs for worker debugging
- [x] Explain how the system is monitored under load

---

## 9. Tech Stack & Infrastructure

- [x] Clearly state the backend framework (Node.js / Python / Go / etc.)
- [x] Justify the choice of queue system
- [x] Use a database or Redis to store job metadata
- [x] Provide a `Dockerfile`
- [x] Provide a `docker-compose.yml`
- [x] Use environment variables for configuration

---

## 10. Repository & Documentation

### 10.1 Code Structure

- [x] Clearly separate:
  - API layer
  - Queue management
  - Worker
  - Execution logic
  - Data models
- [x] Code is readable and well-organized

---

### 10.2 README.md

- [ ] Include setup instructions
- [ ] Describe the system architecture
- [ ] Document the APIs
- [ ] Explain design decisions
- [ ] List possible improvements with more time

---

### 10.3 DESIGN.md (or equivalent section)

- [ ] Describe the end-to-end request flow
- [ ] Explain the execution lifecycle
- [ ] Address idempotency
- [ ] Discuss scalability considerations
- [ ] Highlight technical trade-offs

---

## 11. Bonus (Optional)

- [ ] Unit tests
- [ ] Integration tests
- [ ] Failure scenario tests
- [ ] Optional deployed demo (Railway / Render / similar)

---
