# 04. SWE Intern – Backend  
## Take-home Assignment (Live Code Execution)

**Role:** SWE Intern – Backend  
**Product Focus:** AI-enabled Job Simulation Platform – Live Code Execution Feature

---

## Assignment Objective

The objective of this assignment is to evaluate your ability to **design and implement a secure, reliable backend system** for executing user-submitted code within our Job Simulation platform.

You are expected to demonstrate:
- How the system receives code from users
- How it runs code in an isolated and controlled environment
- How it returns execution results such as output or errors

---

## Submission Instructions

- Submit your case study (**PDF format, max 10–15 slides**)
- Send to: **hr@edtronaut.ai**
- CC: **tram@edtronaut.ai**
- Deadline: **within 3 days** of receiving this case

> You may use AI tools. Since AI is accessible to everyone, we will assess:
> - Critical thinking
> - Prompt engineering skill
> - Domain expertise (if any)

---

# 1. BACKGROUND

## 1.1 About Edtronaut

Edtronaut is redefining workforce readiness through an **AI-enabled Job Simulation Platform**.

### Key Features

- **Hands-On Experience**  
  Simulations mirror real-world job responsibilities, tasks, and co-worker / stakeholder interactions.

- **Tangible Outcomes**  
  Project outputs are portfolio-worthy artifacts (projects, reports, results, AI agents).

- **Social Sharing**  
  Share completed projects on LinkedIn, Facebook, Threads, etc.

### Links
- Homepage: https://edtronaut.ai/
- Job Simulation: https://job-simulations.edtronaut.ai/ed
- CV PowerUP: https://edtronaut.ai/cv-powerup

---

## 1.2 The Scenario

### Current Situation

The Job Simulation platform currently supports learner responses via:
- Text inputs
- File uploads

This approach is **not sufficient for technical roles**, where candidates must:
- Write code
- Run code
- Test code

### Goal

Extend the platform with a **live coding capability**, allowing learners to:
- Write
- Run
- Validate code directly inside simulation tasks

---

# 2. THE ASSIGNMENT (THE ASK)

Design the **backend system and presentation** for a **Live Code Execution & Management** feature that allows learners to:

1. Write and update code in real time  
2. Submit code for execution  
3. Receive execution results and basic feedback  
4. Evaluate benefits and drawbacks of the system  

---

## Core Capabilities

Your system should support:

- Create a live coding session  
- Autosave code changes  
- Execute user code  
- Return execution output:
  - stdout
  - stderr
  - runtime status
- Handle high concurrency without blocking requests (optional)

---

## 2.1 API Requirements (Live Code)

### 2.1.1 Create Live Code Session

**POST /code-sessions**

- Create a new live coding session
- Initialize language, template code, environment

**Response**
```json
{
  "session_id": "uuid",
  "status": "ACTIVE"
}
````

---

### 2.1.2 Autosave Code

**PATCH /code-sessions/{session_id}**

* Autosave learner’s current source code
* Called frequently during live editing

**Request**

```json
{
  "language": "python",
  "source_code": "print('Hello World')"
}
```

**Response**

```json
{
  "session_id": "uuid",
  "status": "ACTIVE"
}
```

---

### 2.1.3 Run Code

**POST /code-sessions/{session_id}/run**

* Execute code asynchronously
* Must return immediately

**Response**

```json
{
  "execution_id": "uuid",
  "status": "QUEUED"
}
```

---

## 2.2 Code Execution APIs

### 2.2.1 Get Execution Result

**GET /executions/{execution_id}**

**Execution States**

* QUEUED
* RUNNING
* COMPLETED
* FAILED
* TIMEOUT

**When COMPLETED**

```json
{
  "execution_id": "uuid",
  "status": "COMPLETED",
  "stdout": "Hello World\n",
  "stderr": "",
  "execution_time_ms": 120
}
```

---

## Execution & Worker System

* Execution must be **asynchronous**
* Use **queue-based worker system** (e.g. Redis)
* Each execution runs in an **isolated environment** (conceptual is OK)

### Enforce

* Time limits
* Memory limits
* Language restrictions

### Other Requirements

* Retry for transient failures
* Prevent blocking API requests

---

## Observability & Safety

* Log execution lifecycle:

  * QUEUED → RUNNING → COMPLETED / FAILED
* Track timestamps for each stage
* Protect against:

  * Infinite loops
  * Excessive resource usage
  * Repeated execution abuse

---

## Out of Scope

* Advanced scoring / grading logic
* ML-based code evaluation
* Frontend implementation
* Real container orchestration (Docker/K8s)

  > Conceptual explanation is enough

---

# 3. TECHNICAL SPECIFICATIONS

## 3.1 Tech Stack

### Backend Framework (choose one)

* Node.js (Express / Fastify / NestJS)
* Python (FastAPI / Flask / Django)
* Go (Gin / Fiber / Echo)
* Any other language you’re comfortable with

### Queue

* Redis (Bull / BullMQ, RQ / Celery)
* Any lightweight queue system (explain your choice)

### Database

* PostgreSQL / SQLite / in-memory
* Redis-only is acceptable if job metadata is stored there

### Infrastructure

* Dockerized
* Include `docker-compose.yml`
* Use environment variables

---

## 3.2 What We’re NOT Looking For

* Production-grade ML models
* Complex authentication / authorization
* UI / Frontend
* Perfect scaling to millions of requests

---

# 4. DELIVERABLES

## 4.1 Code Repository

### Requirements

1. Clear structure:

   * API layer
   * Queue management
   * Execution logic (worker/service)
   * Data models

2. `README.md` must include:

   * Setup instructions
   * Architecture diagram / explanation
   * API documentation
   * Design decisions & trade-offs
   * Improvements with more time

3. Docker setup:

   * Dockerfile
   * docker-compose.yml
   * One-command setup

4. **Tests (Bonus)**

   * Unit tests
   * Integration tests
   * Failure scenario tests

---

## 4.2 Documentation

Include `DESIGN.md` or section in README:

### Architecture Overview

* End-to-end request flow
* Queue-based execution
* Execution lifecycle & state management

### Reliability & Data Model

* Execution states
* Idempotency
* Failure handling & retries

### Scalability

* Concurrent sessions
* Worker scaling
* Queue backlog handling
* Bottlenecks & mitigation

### Trade-offs

* Technology choices
* Optimization goals
* Production readiness gaps

---

## Submission Format

* Public GitHub repository (or access granted)
* README.md
* Optional deployed demo (Railway, Render, Vercel)

---

# 5. APPENDIX

Reference for Upskilling, Reskilling & Workforce Development platforms.